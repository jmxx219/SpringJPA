# 연관관계 매핑

### 목차

- [연관관계 매핑 기초](#연관관계-매핑-기초)
  - [연관관계가 필요한 이유](#연관관계가-필요한-이유)
  - [단방향 연관관계](#단방향-연관관계)
  - [양방향 연관관계](#양방향-매핑)
  - [연관관계의 주인과 mappedBy](#연관관계의-주인과-mappedBy)
  - [정리](#정리)

<br/>

## 연관관계 매핑 기초

### 연관관계가 필요한 이유

> **객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.**  
> 조영호(`객체지향의 사실과 오해`)

<br/>

#### 객체를 테이블에 맞추어 모델링

- 연관관계가 없는 객체
  ```java
  @Entity
  public class Member {
      @Id @GeneratedValue
      private Long id;
      
      @Column(name = "USERNAME")
      private String name;
      
      @Column(name = "TEAM_ID")
      private Long teamId;
  }
  
  @Entity
  public class Team {
      @Id @GeneratedValue
      private Long id;
      private String name;
  }
  ```
  - 참조 대신에 외래키를 그대로 사용함
  ```java
  Team team = new Team();
  team.setName("TeamA");
  em.persist(team);
  
  Member member = new Member();
  member.setUserName("member1");;
  member.setTeamId(team.getId());
  em.persist(member);
  
  Member findMember = em.find(Member.class, member.getId());
  Long teamId = findMember.getTeamId(); // 연관관계가 없음
  Team findTeam = em.find(Team.class, teamId);
  ```
  - 외래키 식별자를 직접 다뤄서 저장함
  - 식별자로 다시 조회하는데, 이는 객체 지향적인 방법이 아님
    - `member`를 조회했음에도 불구하고 `member`가 속한 `team`을 알기 위해서 `teamId(FK)`로 다시 조회해서 가져와야 함
    - 연관관계가 없어 객체지향스럽지 않음

#### **테이블 중심 설계의 문제점**
- 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없음
  - 테이블은 외래키로 조인을 사용해서 연관된 테이블을 찾음
  - 객체는 참조를 사용해서 연관된 객체를 찾음
  - 테이블과 객체 사이에는 큰 가격이 존재함

<br/>

### 단방향 연관관계

#### 객체 지향 모델링

- 객체 연관관계 사용
  - Team의 Id가 아닌 Team 참조 값을 그대로 가져옴
  - Member 객체의 Team 레퍼런스와 Member 테이블의 Team_Id(FK)를 매핑함
- 객체의 참조와 테이블의 외래키를 매핑
  ```java
  @Entity
  public class Member {
      @Id @GeneratedValue
      private Long id;
        
  //    @Column(name = "TEAM_ID")
  //    private Long teamId;
        
      @ManyToOne
      @JoinColumn(name = "TEAM_ID")
      private Team team;
  }
  ```
  - 연관관계가 무엇인지(다대일), 이 관계를 정의할 때 조인하는 컬럼은 무엇인지 나타냄
- ORM 매핑
- 연관관계 저장
  ```java
  // member.setTeamId(team.getId());
  member.setTeam(team); 
  ```
  - member에 team을 참조해서 저장하면, JPA가 DB에 엔티티를 저장할 때 알아서 team 엔티티에서 `PK` 값을 꺼내 member 테이블의 `FK` 컬럼에 저장함
- 참조로 연관관계 조회 - 객체 그래프 탐색
  ```java
  Member findMember = em.find(Member.class, member.getId());
  Team findTeam = member.getTeam(); // 참조 사용해서 연관관계 조회
  ```
- 연관관계 수정
  ```java
  Team teamB = new Team(); //새로운 팀 B
  teamB.setName("TeamB");
  em.persist(teamB);
    
  member.setTeam(teamB); //회원에 새로운 팀B 설정
  ```
  - 더티 체킹을 이용한 연관관계 수정

<br/>


### 양방향 연관관계

- 테이블의 연관관계에는 외래키 하나에 양방향이 다 존재함
  - 테이블은 외래키로 조인해서 연관 관계를 만들기 때문
    - Member에서 자신이 속한 팀을 알고 싶으면 Member의 TEAM_ID(FK)와 TEAM의 TEAM_ID(PK)를 조인하면 됨
    - Team에서 속해있는 멤버들을 알고 싶으면 TEAM의 TEAM_ID(PK)와 Member의 TEAM_ID(FK)를 조인하면 됨
  - 사실 방향이란 개념 자체가 없음
- 객체는 참조를 통해 연관관계를 설정하기 때문에, Team에서 Member에서 서로에 대한 참조를 모두 가지고 있어야 함

  <br/>

  <img src="https://github.com/jmxx219/SpringJPA/assets/52346113/f684825f-2180-45d1-adb9-2b19912c800e" height="200" width="350"/>

  <br/>

- 엔티티
  - Member 엔티티는 단방향과 동일함
  - Team 엔티티에만 member 컬렉션을 추가
      ```java
      @Entity
      public class Team {
          ...
          @OneToMany(mappedBy = "team") 
          private List<Member> members = new ArrayList<Member>(); // 추가
      }
      ```
  - 반대 방향으로 객체 그래프 탐색 가능
    ```java
    Member findMember = em.find(Member.class, member.getId());
    List<Member> members = findMember.getTeam().getMembers(); // 역방향 조회
    ```

> 양방향으로 매핑하면 신경써야할 점이 많기 때문에 가급적이면 단방향이 좋음


<br/>

### 연관관계의 주인과 mappedBy

- `mappedBy`는 JPA에서 이해하기 가장 어려운 부분임
- **객체와 테이블간에 연관관계를 맺는 차이를 이해해야 함!**

<br/>

#### 객체와 테이블이 관계를 맺는 차이

- 객체의 양방향 관계
  - 객체 연관관계 = 2개
    - 회원 ➜ 팀 연관관계 1개 (단방향)
    - 팀 ➜ 회원 연관관계 1개 (단방향)
  - 객체의 양방향 관계는 사실 양방향 관계가 아닌 `서로 다른 단방향 관계 2개`임
    - 객체 세상에서는 양방향 연관관계를 맺으려면, 참조가 양쪽 객체에 있어야 함
- 테이블의 양방향 연관관계
  - 테이블 연관관계 = 1개
    - 회원 ↔ 팀 `연관관계 1개` (양방향, 사실 방향이 없는 것)
  - 테이블은 외래 키 하나도 두 테이블의 연관관계를 관리함
    - 외래키 값 하나로 테이블을 조인하면 양방향 연관관계를 가짐

<br/>

#### 둘 중 하나로 외래키를 관리해야 함

- 두 가지 참조 값이 존재
  - Member ➜ Team 참조값
  - Team ➜ Member 참조값
- 둘 중 어떤 것으로 테이블의 외래키에 매핑해야 하는지에 대한 고민
  - `Member` 객체의 team 값을 변경했을 때, 외래키 값이 업데이트 되어야 하는지
  - `Team` 객체의 members 값을 변경했을 때, 외래키 값이 업데이트 되어야 하는지
- DB 입장에서는 `TEAM_ID(FK)`만 업데이트되면 되기 때문에 둘 중 하나로 외래키를 관리해야 함!
  - 둘 중 어떤 것(Team이나 Member)으로 관리를 해야할 지 주인을 정해야 함(이것이 `연관관계의 주인`)


<br/>

#### 연관관계의 주인(Owner)

- 양방향 매핑 규칙
  - 객체의 두 관계 중, 하나를 연관관계의 주인으로 지정
  - 연관관계의 주인만이 외래키를 관리(등록, 수정)
  - 주인이 아닌 쪽은 읽기만 가능
  - 주인은 `mappedBy` 속성 사용 x
  - 주인이 아니면 `mappedBy` 속성으로 주인 지정
- 그래서 누구를 주인으로?
  - **외래 키가 있는 곳을 주인으로❗❗**
    - `ManyToOne`의 `Many` 쪽이 연관관계의 주인으로 하면 됨
    - 여기서는 Member.team이 연관관계의 주인

  <br/>

  <img src="https://github.com/jmxx219/SpringJPA/assets/52346113/fcf3f6df-2e73-47b2-bc4c-fb2592f4feef" height="200" width="400"/>

  <br/>

- 외래키가 있는 쪽의 테이블과 대응되는 엔티티에 있는 참조를 연관관계의 주인으로 정하는 것이 헷갈리지 않음
  - 만약 외래키가 있는 곳이 아닌 Team.members를 연관관계의 주인으로 정할 경우
  - Team에 있는 members를 수정했는데 Update 쿼리는 다른 테이블(Member)에 날아감(헷갈림)
- 외래키가 존재하는 엔티티에서 관리를 나중에 문제가 발생하지 않음
  - DB 입장에서는 `ManyToOne(다대일)` 관계에서 외래키가 있는 쪽이 `Many(다)`고 외래키가 없는 쪽이 `One(일)`임
    - DB의 `Many`쪽이 무조건 연관관계의 주인이 됨
  - 객체에서는 `@ManyToOne`, `@XXXToOne` 쪽이 무조건 연관관계의 주인이 됨
  - 연관관계의 주인은 비즈니스적으로 큰 의미가 없음
- 외래키가 있는 쪽이 연관관계 주인이 되어야 설계가 깔끔해짐


<br/>

#### 양방향 매핑시 가장 많이 하는 실수

- 연관관계의 주인에 값을 입력하지 않음
  ```java
  Team team = new Team );
  team.setName("TeamA");
  em.persist(team);
    
  Member member = new Member();
  member.setName("member1");
    
  team.getMembers().add(member); //역방향(주인이 아닌 방향)만 연관관계 설정
    
  em.persist(member);
  ```
  - 연관관계의 주인만이 외래키 값을 등록, 수정할 수 있음
    - 연관관계의 주인이 아닌쪽은 조회만 가능함
  - JPA에서 update나 insert할 때는 `mappedBy`된 쪽은 보지 않음
    - `mappedBy`는 그냥 읽기 전용, 가짜 매핑이기 때문에 실제로 DB에 반영되지 않음
- 양방향 매핑시 연관관계의 주인에만 값을 입력(양쪽에 다 값을 입력하지 않는 경우)
  ```java
  Team team = new Team();
  team.setName("TeamA");
  em.persist(team);
    
  Member member = new Member();
  member.setName("member1");
  member.setTeam(team); //연관관계의 주인에 값 설정
  
  em.persist(member);
  ```
  - 연관관계의 주인에만 값을 설정해주면 영속성 컨텍스트에 있는 team 객체의 member 컬렉션은 여전히 비어있는 상태
    - 따라서 트랜잭션 안에서 영속성 컨텍스트에 flush하고 clear 되기 전에 해당 컬렉션을 조회하면 정상적인인 결과가 출력되지 않음
    - 물론, 커밋 시점에는 연관관계의 주인에 의해서 DB에 업데이터 쿼리가 날아감
  - 테스트 케이스 작성 시, JPA 없이도 동작하게 순수 자바 코드로 작성하기 때문에 `Team.getMembers()`를 하면 값이 없어 null로 나오는 문제가 발생


- 결론
  - 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자
  - `연관관계 편의 메서드`를 생성하자
    ```java
    @Entity
    public class Member {
        @ManyToOne
        @JoinColumn(name = "TEAM_ID")
        private Team team;
    
        public Team getTeam() {
            return team;
        }
    
        public void changeTeam(Team team) {
            this.team = team;
            team.getMembers().add(this);
        }
    }
    ```
    - 진짜 주인에 값을 넣을 때, 자동으로 가짜 주인에도 넣을 수 있도록 편의 메소드를 활용
      - 연관관계 편의 메서드나 JPA 상태를 변경하는 건 setter를 활용하지 않음
    - 이는 단순하게 getter, setter 관례에 의한게 아니라 어떤 작업을 수행하는지 명확하게 알 수 있어 좋음
  - 양방향 매핑 시, 무한루프를 조심하자
    - Lombok의 toString()은 사용하지 말기
    - JSON 생성 라이브러리와 관련해서 컨트롤러에서 entity를 절대 반환하지 않기
      - entity를 반환할 경우 문제가 생김
        - 무한루프 발생
        - 나중에 entity를 변경하는 순간 API 스펙이 바뀌어 버림
      - DTO을 변환해서 반환하는 것이 좋음

<br/>

#### 양방향 매핑 정리

- 단방향 매핑만으로도 이미 연관관계 매핑은 완료
  - JPA 모델링할 때 단방향 매핑으로 처음 설계를 끝내야 함(양방향 매핑을 하면 안됨)
    - 실무에서는 사실 객체만으로 설계할 수 없고, 테이블 설계를 먼저 그리면서 객체 설계를 같이 들어가야 함
    - 그 시점에 테이블 관계에서 대략전인 FK가 나옴
      - 결국 `Many` 쪽에서 단방향 매핑(ManyToOne, OneToOne)을 다 걸어서 들어가야하기 때문에 이때 양방향 매핑을 하지 말자
- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐임
- JPQL에서 역방향으로 탐색할 일이 많음
- 단방향 매핑을 잘하고 양방향은 필요할 때 추가해도 됨(`테이블에 영향을 주지 않음`)
  - **처음에 무조건 단방향 매핑으로 설계를 끝내고, 그리고 나서 역방향으로 조회 기능이 필요할 때 양방향을 사용하기**


<br/>

### 정리
- JPA 사용 시, 엔티티 설계할 때
  - 단방향 매핑으로 모두 끝내기
  - `일대다`일 때 `Many(다)`쪽에 연관관계 매핑을 전부 설정해주고 설계를 끝내기
  - 실제 애플리케이션을 개발하는 단계에서 양방향 매핑을 고려
    - 객체 입장에서 양방향 매핑이 크게 이득되는 것이 없음
- 연관관계의 주인을 정하는 기준
  - 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨
  - 연관관계의 주인은 외래 키의 위치를 기준으로 정해야함


 <br/>








 