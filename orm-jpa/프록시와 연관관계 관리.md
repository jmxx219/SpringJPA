# 프록시와 연관관계 관리


### 목차

- [프록시](#프록시)



<br/>


## 프록시

### 등장 배경

- 엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아님
  - 연관관계의 엔티티는 비즈니스 로직에 따라 사용될 때도 있지만 그렇지 않을 때도 있음
  - Member를 조회할 때 Team도 함께 조회해야 할까?
    - 회원과 팀을 함께 사용하는 비즈니스 로직이 많을 경우
      ```java
      public void printUserAndTeam(String memberId) {
          Member member = em.find(Member.class, memberId);
          Team team = member.getTeam();
          System.out.println("회원 이름: " + member.getUsername());
          System.out.println("소식팀: " + team.getName()); // team 객체 조회
      }
      ```
      - Member와 Team을 따로 쿼리날려서 조회하는 것보다 Member를 조회할 때 연관된 Team까지 한 번에 조회하는 것이 성능상 좋음
    - 회원만 필요한 경우
      ```java
      public void printUser(String memberId) {
          Meber member = em.find(Member.class, memberId);
          Team team = member.getTeam();
          System.out.println("회원 이름: " + member.getUsername());
      }
      ```
      - 이때는 굳이 Team까지 함께 가져올 필요가 없음
- JPA는 이러한 문제를 해결하기 위해 `지연로딩`과 `프록시` 기술을 제공함
  - `지연로딩`: 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법
  - `프록시 객체`: 지연 로딩을 사용할 수 있도록 실제 엔티티 객체 대상에 데이터베이스 조회를 지연할 수 있게 하는 가짜 객체

<br/>


### 프록시 기초

#### `em.find()` vs `em.getReference()`
- `EntityManager.find()`
  - 데이터베이스를 통해서 실제 엔티티 객체 조회
    - `Member member = em.find(Member.class, "member1");`
  - 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회함
- `EntityManager.getReference()`
  - 데이터베이스 조회를 미루는 가짜(`프록시`) 엔티티 객체 조회
    ```java
    Member findMember = em.getReference(Member.class, member.getId()); // DB 쿼리 질의 x
    System.out.println("findMember = " + findMember.getClass()); // Hibernate가 강제로 만들어낸 proxy 클래스 (가짜 객체)
    System.out.println("findMember.id = " + findMember.getId()); // id는 paramter로 넘어와서 DB에서 안가져와도 알고 있음
    System.out.println("findMember.name = " + findMember.getUsername()); // 실제 객체의 멤버변수에 접근할때 DB에 쿼리 질의 o
    ```
  - 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶을 때 사용
  - 데이터이스 접근을 위임한 프록시 객체가 반환됨
    - 프록시 객체는 실제 객체에 대한 `참조(target)`를 보관함
    - 프록시 객체의 메소드를 호출하면 프록시 객체는 실제 객체의 메서드를 호출함(객체 초기화)

<br/>

#### 프록시 객체의 초기화
- 동작 흐름
  ```java
  Member member = em.getReference(Member.class, “id1”);
  member.getName();
  ```
  
  <img src="https://github.com/jmxx219/SpringJPA/assets/52346113/dddde104-cda5-4a21-81bc-db8bbb18b862" height="200" width="320" />
    <br/>
  <br/>

  1. 클라이언트가 프록시 객체의 `getName()` 호출
  2. 프록시 객체가 target이 null이면, JPA(정확히는 hibernate)가 영속성 컨텍스트에 진짜 객체를 요청함(**초기화 요청**)
  3. 영속성 컨텍스트가 DB를 조회
  4. 실제 entity를 생성해서 반환
  5. 프록시의 target이 생성된 member 엔티티를 가리키고 있어, 실제 member 엔티티의 `getName()` 호출


<br/>

#### 프록시 확인

- 프록시 인스턴스의 초기화 여부 확인
  - `PersistenceUnitUtil.isLoaded(Object entity)`
- 프록시 클래스 확인 방법
  - `entity.getClass().getName()` 출력(..javasist.. or HibernateProxy...)
- 프록시 강제 초기화
  - `org.hibernate.Hibernate.initialize(entity);`
- 참고
  - JPA 표준은 강제 초기화 없음
  - 강제 호출: `member.getName()`

<br/>

### 프록시 특징
- 실제 클래스를 상속 받아 만들어져서 실제 클래스와 겉 모양이 같음
  - hibernate가 내부적으로 proxy 라이브러리들을 사용해서 만들어냄
  - 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨(이론상)
- 프록시 객체는 실제 객체의 참조(`target`)를 보관
  - 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출함
  - 처음에는 DB를 조회하지 않아서 target에 참조 값이 없음
- 프록시 객체는 처음 사용할 때 한 번만 초기화
  - 프록시 객체를 초기화할 때, 프록시 객체가 **실제 엔티티로 바뀌는 것은 아님**
    - 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능한 것일 뿐(target 초기화)
- 프록시 객체는 원본 엔티티를 상속받기 때문에 타입 체크시 주의해야함
  - `==` 비교를 하면 프록시 객체와 실제 객체와 타입이 안맞기에 실패함
  - 대신 `instance of`를 사용해야 함
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 `em.getReference()`를 호출해도 실제 엔티티를 반환함
  - JPA는 같은 트랜잭션안에 같은 영속성 컨텍스트에서 조회되는 엔티티의 동일성을 보장해야 함
    - `==` 비교가 무조건 `true`가 되도록 함
  - 프록시로 한 번 조회가 되면 `em.find()`도 `==` 비교를 맞추기 위해 프록시를 반환함
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제가 발생함
  - 초기화는 영속성 컨텍스트의 도움을 받아야 가능한데, 트랜잭션이 종료되고 영속성 컨텍스트를 조회하면 에러가 발생함
  - 하이버네이트는 `org.hibernate.LazyInitializationException` 예외를 터트림(실무에서 많이 발생)

<br/>

